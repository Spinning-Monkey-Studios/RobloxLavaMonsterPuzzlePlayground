-- Lava hitbox tuning (prevents edge/bridge false hits)
local EDGE_INSET   = 0.35   -- studs to shrink on X/Z (away from edges)
local ZONE_HEIGHT  = 0.8    -- thin detection height
local OFFSET_BELOW = 0.15   -- how far below the visible surface to place the zone

-- Level-aware lava damage: immediate hide, darker UI, reliable rebinds
local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local RS         = game:GetService("ReplicatedStorage")
local Life       = require(RS:WaitForChild("Life"))

-- Tuning (DPS â‰ˆ DAMAGE_PER_TICK / DAMAGE_INTERVAL)
local DAMAGE_PER_TICK = 5
local DAMAGE_INTERVAL = 0.10

-- State
local touchCount  = {}   -- [Player] = touching parts count
local lastTick    = {}   -- [Player] = os.clock()
local loops       = {}   -- [Player] = Heartbeat conn
local guis        = {}   -- [Player] = ScreenGui
local boundZones  = {}   -- for cleanup
local rebindConn1, rebindConn2

-- ---------- smoke ----------
local function getRoot(char)
	return char and (char:FindFirstChild("HumanoidRootPart")
		or char:FindFirstChild("LowerTorso") or char:FindFirstChild("Torso"))
end
local function ensureSmoke(char)
	local root = getRoot(char); if not root then return end
	local pe = root:FindFirstChild("LavaSmoke")
	if not pe then
		pe = Instance.new("ParticleEmitter")
		pe.Name = "LavaSmoke"; pe.Enabled = false
		pe.EmissionDirection = Enum.NormalId.Top; pe.Rate = 50
		pe.Lifetime = NumberRange.new(1.2,2.2); pe.Speed = NumberRange.new(0.5,2)
		pe.Acceleration = Vector3.new(0,8,0)
		pe.Rotation = NumberRange.new(-180,180); pe.RotSpeed = NumberRange.new(-30,30)
		pe.Size = NumberSequence.new{
			NumberSequenceKeypoint.new(0,0.8),
			NumberSequenceKeypoint.new(0.4,1.6),
			NumberSequenceKeypoint.new(1,2.2),
		}
		pe.Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0,0.3),
			NumberSequenceKeypoint.new(1,1)
		}
		pe.Color = ColorSequence.new(Color3.fromRGB(200,200,200), Color3.fromRGB(120,120,120))
		pe.Parent = root
	end
	return pe
end
local function setSmoke(plr, on)
	local char = plr.Character; if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum then hum:SetAttribute("Status_Burning", on == true) end
	local pe = ensureSmoke(char); if pe then pe.Enabled = on and true or false end
end

-- ---------- GUI (darker) ----------
local function destroyGui(p) if guis[p] then guis[p]:Destroy(); guis[p]=nil end end
local function createGui(p)
	destroyGui(p)
	local pg = p:FindFirstChild("PlayerGui"); if not pg then return end

	local gui = Instance.new("ScreenGui")
	gui.Name = "DamageGUI"; gui.ResetOnSpawn = false; gui.Parent = pg

	local frame = Instance.new("Frame")
	frame.Name="DamageFrame"; frame.Size=UDim2.new(0,330,0,42); frame.Position=UDim2.new(0.5,-165,0,52)
	frame.BackgroundColor3=Color3.fromRGB(15,8,16); frame.BackgroundTransparency=0.15; frame.BorderSizePixel=0
	frame.Parent=gui; Instance.new("UICorner",frame).CornerRadius=UDim.new(0,10)

	local bg = Instance.new("Frame")
	bg.Name="BarBackground"; bg.Size=UDim2.new(1,-12,0.6,0); bg.Position=UDim2.new(0,6,0.2,0)
	bg.BackgroundColor3=Color3.fromRGB(35,25,35); bg.BorderSizePixel=0; bg.Parent=frame
	Instance.new("UICorner",bg).CornerRadius=UDim.new(0,6)

	local fill = Instance.new("Frame")
	fill.Name="BarFill"; fill.Size=UDim2.new(1,0,1,0); fill.BackgroundColor3=Color3.fromRGB(150,30,60)
	fill.BorderSizePixel=0; fill.Parent=bg; Instance.new("UICorner",fill).CornerRadius=UDim.new(0,6)

	local label = Instance.new("TextLabel")
	label.Name="DamageLabel"; label.Size=UDim2.new(1,0,1,0); label.BackgroundTransparency=1
	label.TextColor3=Color3.fromRGB(255,140,220); label.TextScaled=true; label.Font=Enum.Font.GothamBold
	label.Text="Health: 100/100"; label.Parent=frame

	guis[p] = gui
end
local function updateGui(p, cur, max)
	local gui = guis[p]; if not gui then return end
	gui.DamageFrame.BarBackground.BarFill.Size = UDim2.new(math.clamp(max>0 and cur/max or 1,0,1),0,1,0)
	gui.DamageFrame.DamageLabel.Text = string.format("Health: %d/%d", math.floor(cur), max)
end

-- ---------- loop ----------
local function stopLoop(p)
	if loops[p] then loops[p]:Disconnect(); loops[p]=nil end
	setSmoke(p,false); destroyGui(p)
end
local function ensureLoop(p)
	if loops[p] then return end
	createGui(p); setSmoke(p,true); lastTick[p] = os.clock()
	loops[p] = RunService.Heartbeat:Connect(function()
		local char = p.Character; local hum = char and char:FindFirstChildOfClass("Humanoid")
		if not hum or hum.Health<=0 then stopLoop(p); return end
		if (touchCount[p] or 0) <= 0 then stopLoop(p); return end  -- immediate hide

		local t = os.clock()
		if t - (lastTick[p] or 0) >= DAMAGE_INTERVAL then
			Life.Damage(hum, DAMAGE_PER_TICK)
			lastTick[p] = t
		end
		local cur = hum:GetAttribute("LifePoints") or 100
		local max = hum:GetAttribute("MaxLifePoints") or 100
		updateGui(p, cur, max)
	end)
end

-- ---------- touch counting ----------
local function onTouched(hit)
	local p = Players:GetPlayerFromCharacter(hit.Parent); if not p then return end
	touchCount[p] = (touchCount[p] or 0) + 1
	ensureLoop(p)
end
local function onTouchEnded(hit)
	local p = Players:GetPlayerFromCharacter(hit.Parent); if not p then return end
	touchCount[p] = math.max(0, (touchCount[p] or 0) - 1)
	if touchCount[p] == 0 then stopLoop(p) end -- immediate hide
end

-- ---------- binding ----------
local function clearBoundZones()
	for _, conns in pairs(boundZones) do
		for _,c in ipairs(conns) do c:Disconnect() end
	end
	table.clear(boundZones)
end

-- In LavaDamage.server.lua, replace the whole bindOneSurface with this:
local function bindOneSurface(surface)
	if not surface:IsA("BasePart") then return end

	-- Only the invisible zone should generate touches
	surface.CanTouch = false
	local parent = surface.Parent
	local floor  = parent:FindFirstChild("LavaFloor")
	if floor and floor:IsA("BasePart") then floor.CanTouch = false end

	-- Build or reuse a thin, inset touch zone just below the visible lava
	local zone = surface:FindFirstChild("TouchZone")
	if not zone then
		zone = Instance.new("Part")
		zone.Name = "TouchZone"
		zone.Anchored = true
		zone.CanCollide = false
		zone.CanQuery  = false
		zone.CanTouch  = true
		zone.Transparency = 1 -- set to 0.5 temporarily to visualize
		zone.Parent = surface
	end

	-- Use your tuning constants at the top of the file:
	-- EDGE_INSET, ZONE_HEIGHT, OFFSET_BELOW
	local sx = math.max(0.2, surface.Size.X - EDGE_INSET * 2)
	local sz = math.max(0.2, surface.Size.Z - EDGE_INSET * 2)
	zone.Size  = Vector3.new(sx, ZONE_HEIGHT, sz)

	-- Sit the zone slightly *below* the visible surface
	zone.CFrame = surface.CFrame * CFrame.new(0, -(OFFSET_BELOW + ZONE_HEIGHT * 0.5), 0)

	-- (Re)connect handlers
	if boundZones[zone] then
		for _,c in ipairs(boundZones[zone]) do c:Disconnect() end
	end
	boundZones[zone] = {
		zone.Touched:Connect(onTouched),
		zone.TouchEnded:Connect(onTouchEnded),
	}
	print("[LavaDamage] Bound lava zone (pancake):", zone:GetFullName(), "size", zone.Size)
end


local function getActiveRoot()
	return workspace:FindFirstChild("ActiveLevel") or workspace
end

local function rebind()
	clearBoundZones()
	local root = getActiveRoot()
	local lavaFolder = root:FindFirstChild("Lava", true) or root:FindFirstChild("Lava")
	if not lavaFolder then
		warn("[LavaDamage] No 'Lava' folder found under ActiveLevel/Workspace.")
		return
	end
	local found = 0
	for _, d in ipairs(lavaFolder:GetDescendants()) do
		if d:IsA("BasePart") and d.Name == "LavaSurface" then
			found += 1; bindOneSurface(d)
		end
	end
	if found == 0 then
		warn("[LavaDamage] No LavaSurface parts found under:", lavaFolder:GetFullName())
	end
end

-- initial + level swap rebinds
rebind()
if rebindConn1 then rebindConn1:Disconnect() end
if rebindConn2 then rebindConn2:Disconnect() end
rebindConn1 = workspace.ChildAdded:Connect(function(c) if c.Name=="ActiveLevel" then task.defer(rebind) end end)
rebindConn2 = workspace.ChildRemoved:Connect(function(c) if c.Name=="ActiveLevel" then clearBoundZones() end end)

-- cleanup
local function cleanup(p) touchCount[p]=nil; lastTick[p]=nil; stopLoop(p) end
Players.PlayerRemoving:Connect(cleanup)
for _,p in ipairs(Players:GetPlayers()) do p.CharacterRemoving:Connect(function() cleanup(p) end) end
Players.PlayerAdded:Connect(function(p) p.CharacterRemoving:Connect(function() cleanup(p) end) end)
